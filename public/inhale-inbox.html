<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì™¸ë¶€ì§€ì‹ ë“¤ìˆ¨(ì¡°í•©ì‹¤)</title>
  <style>
    :root{
      --bg:#0b1020; --card:rgba(255,255,255,0.06); --line:rgba(255,255,255,0.10);
      --text:rgba(255,255,255,0.92); --muted:rgba(255,255,255,0.68);
      --primary:#4aa3ff; --danger:#ff5b5b;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(74,163,255,.12), transparent 60%),
        radial-gradient(1000px 500px at 80% 10%, rgba(46,204,113,.10), transparent 55%),
        var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif;
    }
    .wrap{max-width:900px;margin:0 auto;padding:18px 14px 60px}
    a{color:var(--primary);text-decoration:none}
    .title{font-size:22px;font-weight:800;margin:10px 0 6px}
    .sub{color:var(--muted);line-height:1.6;margin:0 0 14px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:14px;box-shadow:var(--shadow)}
    .meta{display:flex;gap:10px;flex-wrap:wrap;align-items:center;font-size:12px;color:var(--muted)}
    .pill{padding:2px 8px;border:1px solid rgba(231,236,255,0.18);border-radius:999px}
    input,textarea,select{
      width:100%; border-radius:12px; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04); color:var(--text); padding:10px 12px; outline:none;
    }
    textarea{min-height:150px;resize:vertical;line-height:1.6;white-space:pre-wrap}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{
      border-radius:999px; padding:10px 14px; border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06); color:var(--text); cursor:pointer;
    }
    button.primary{background:rgba(74,163,255,.18); border-color:rgba(74,163,255,.35)}
    button.danger{background:rgba(255,91,91,.12); border-color:rgba(255,91,91,.25)}
    .toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background:rgba(20,26,48,.92);border:1px solid var(--line);
      padding:10px 14px;border-radius:999px;opacity:0;transition:opacity .18s ease;
      max-width:min(680px,92vw);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .toast.on{opacity:1}
    code{color:#cfe0ff}
    .anchorTitle{font-size:12px;color:var(--muted);margin-bottom:6px}
    .anchorText{white-space:pre-wrap;line-height:1.6}
  </style>
</head>

<body>
  <div class="wrap">
    <div><a href="/index.html">â† í—ˆë¸Œë¡œ</a></div>
    <div class="title">ğŸ« ì™¸ë¶€ì§€ì‹ ë“¤ìˆ¨ (ì¡°í•©ì‹¤)</div>
    <p class="sub">
      ì—¬ê¸°ëŠ” <b>ì¡°í•©ì‹¤</b>ì´ì•¼. <b>ìŠ¹ê²©ì˜ ì–¸ì–´(ë¨¸ë¬´ëŠ” ìˆ¨ê²°)</b> + <b>ì™¸ë¶€ì§€ì‹</b>ë§Œ ë¶€ë“œëŸ½ê²Œ ì„ì–´.
      (ì €ì¥/ëª©ë¡ ê¸°ëŠ¥ì€ êº¼ì ¸ ìˆì–´)
    </p>

    <!-- ë¨¸ë¬´ëŠ” ìˆ¨ê²°(íšŒì˜ëŒ€ê¸°ì—ì„œ ì˜¨ 1ë¬¸ì¥) -->
    <div id="anchorCard" class="card" style="margin-bottom:12px; display:none;">
      <div class="anchorTitle">ë¨¸ë¬´ëŠ” ìˆ¨ê²° (íšŒì˜ëŒ€ê¸°ì—ì„œ ì˜¨ ìŠ¹ê²© ì–¸ì–´ 1ê°œ)</div>
      <div class="meta" style="margin-bottom:8px;">
        <span class="pill" id="anchorWhen">-</span>
        <span class="pill" id="anchorFrom">meeting-room</span>
      </div>
      <div id="anchorText" class="anchorText"></div>
      <div class="sub" style="margin-top:10px;">
        ìë™ìœ¼ë¡œ í‚¤ì›Œë“œë¥¼ ë½‘ê³ , ë“¤ìˆ¨(ê²€ìƒ‰)ì„ 1íšŒ ì‹¤í–‰í•´.
        í‚¤ì›Œë“œë¥¼ ë°”ê¾¸ê³  <b>Enter</b> ì¹˜ë©´ ë‹¤ì‹œ ë“¤ìˆ¨í•´.
      </div>
    </div>

    <!-- ì¡°í•© ì¹´ë“œ -->
    <div class="card">
      <div style="font-size:12px;color:var(--muted);margin-bottom:8px;">
        ë“¤ìˆ¨(ê²€ìƒ‰) ê²°ê³¼ëŠ” ì•„ë˜ <code>ì™¸ë¶€ì§€ì‹(text)</code>ì— ì±„ì›Œì§€ê³ ,
        <b>ì˜ë¯¸ êµì°¨ë¡œ</b>ë¥¼ ëˆ„ë¥´ë©´ êµì°¨ë°©ìœ¼ë¡œ íë¥¸ë‹¤.
      </div>

      <div class="row">
        <select id="source" style="max-width:220px;">
          <option value="dictionary">ğŸ“˜ êµ­ì–´ì‚¬ì „</option>
          <option value="wiki">ğŸŒ ìœ„í‚¤</option>
          <option value="paper">ğŸ“„ ë…¼ë¬¸/ê¸°ì‚¬</option>
          <option value="etc">âœ¨ ê¸°íƒ€</option>
        </select>
      </div>

      <div class="row">
        <input id="q" placeholder="ìë™ ë“¤ìˆ¨ í‚¤ì›Œë“œ (ì˜ˆ: ì§„ì‹¬)" />
        <textarea id="text" placeholder="ì™¸ë¶€ì§€ì‹(ìš”ì•½/ë°œì·Œ)ì´ ì—¬ê¸°ì— ëª¨ì—¬."></textarea>
      </div>

      <!-- âœ… ë²„íŠ¼ì€ 2ê°œë§Œ -->
      <div class="row">
        <button id="sendToCross" class="primary">ì˜ë¯¸ êµì°¨ë¡œ</button>
        <button id="clear" class="danger">ì§€ìš°ê¸°</button>
      </div>

      <div class="sub" style="margin-top:10px;">
        ë¨¸ë¬´ëŠ” ìˆ¨ê²° í‚¤: <code>harulua.inhale.anchor</code><br/>
        êµì°¨ ì´ë™ í‚¤: <code>harulua.cross.inbox</code> + <code>harulua.cross.inhale.bundle</code>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script>
(function(){
  const ANCHOR_KEY = "harulua.inhale.anchor";
  const CROSS_INBOX_KEY = "harulua.cross.inbox";
  const CROSS_BUNDLE_KEY = "harulua.cross.inhale.bundle";
const AUTO_MODE = new URLSearchParams(location.search).get("auto") === "1";
const AUTO_PUSH_CROSS = new URLSearchParams(location.search).get("pushCross") === "1";
const AUTO_ON_NEW_PROMOTE = true; // âœ… ìƒˆ promoteê°€ ì˜¤ë©´ ìë™ ë“¤ìˆ¨/ìë™ êµì°¨ë¡œê¹Œì§€

  const $ = (id) => document.getElementById(id);
let CURRENT_ANCHOR = null;

  function cleanDictionaryText(text){
  return String(text || "")
    // 1. ì‚¬ì „ ë©”íƒ€ ê¸°í˜¸ ì œê±°
    .replace(/\[\[|\]\]/g, "")

    // 2. ì˜ë¯¸ êµ¬ë¶„ìš© ìŠ¬ë˜ì‹œ â†’ ì‰¼í‘œë¡œ
    .replace(/\s*\/\s*/g, ",")

    // 3. ë‚¨ì•„ìˆì„ ìˆ˜ ìˆëŠ” íŠ¹ìˆ˜ê¸°í˜¸ ì •ë¦¬
    .replace(/[â€»â€¢Â·â—†â–¶â–·â– â–¡â–²â–¼â˜…â˜†]/g, "")

    // 4. ì¤‘ë³µ ë¬¸ì¥ë¶€í˜¸ ì •ë¦¬
    .replace(/[,]{2,}/g, ",")
    .replace(/[.]{2,}/g, ".")

    // 5. ê³µë°± ì •ë¦¬
    .replace(/\s+/g, " ")
    .replace(/\s([,.])/g, "$1")

    .trim();
}


  function safeJsonParse(raw, fallback){
    try { return JSON.parse(raw); } catch { return fallback; }
  }

  function toast(msg){
    const el = $("toast");
    if (!el) return;
    el.textContent = msg;
    el.classList.add("on");
    setTimeout(()=> el.classList.remove("on"), 1200);
  }

async function loadTodayPromoteFromServer(){
  try {
    const res = await fetch("/api/breath-log.json");
    if (!res.ok) return null;

    const data = await res.json();
    if (!data?.items?.length) return null;

 const promotes = data.items
  .filter(it => String(it.messageId || it.id || "").includes("-promote"))
  .filter(it => !it.consumedAt) // âœ… ì¶”ê°€: ì†Œë¹„ëœ ê±´ ì œì™¸
  .sort((a,b) => Date.parse(b.receivedAt || b.at || 0) - Date.parse(a.receivedAt || a.at || 0));

const promote = promotes[0];
if (!promote) return null;

return {
  promoteKey: String(promote.messageId || promote.id || ""),
  text: promote.text,
  createdAt: new Date(promote.receivedAt || Date.now()).toISOString(),
  source: "app-promote",
};

  } catch {
    return null;
  }
}

  function nowIso(){ return new Date().toISOString(); }

  function timeAgo(iso){
    const ms = Date.now() - new Date(iso).getTime();
    const m = Math.floor(ms / 60000);
    if (m < 1) return "ë°©ê¸ˆ";
    if (m < 60) return `${m}ë¶„ ì „`;
    const h = Math.floor(m / 60);
    if (h < 24) return `${h}ì‹œê°„ ì „`;
    const d = Math.floor(h / 24);
    return `${d}ì¼ ì „`;
  }

  // ---- ì¡°ì‚¬ ì œê±°(í‚¤ì›Œë“œ ì •ê·œí™”) ----
  function normalizeKoreanKeyword(word){
    let w = String(word || "").trim();
    const suffixes = [
      "ì—ì„œ","ì—ê²Œ","ê»˜ì„œ","ìœ¼ë¡œ","ë¡œì„œ","ë¡œì¨","ê¹Œì§€","ë¶€í„°","ë¼ë„","ë§ˆì €",
      "ë§Œ","ë„","ì—","ì˜","ë¡œ","ê³¼","ë€","ì´ë€","ì™€","ì„","ë¥¼","ì€","ëŠ”","ë¼ëŠ”","ì´ë¼ëŠ”","ì´","ê°€"
    ];
    for (let k=0; k<3; k++){
      for (const s of suffixes){
        if (w.length >= 3 && w.endsWith(s)){
          w = w.slice(0, -s.length).trim();
          break;
        }
      }
    }
    return w;
  }

  function extractKeywords(text){
    const t = String(text || "")
      .replace(/[^\p{L}\p{N}\s]/gu, " ")
      .replace(/\s+/g, " ")
      .trim();

    if (!t) return [];

    const stop = new Set(["ê·¸ë¦¬ê³ ","ê·¸ëŸ¬ë‚˜","ê·¸ë˜ì„œ","í•˜ì§€ë§Œ","ë˜ëŠ”","ê·¸ëŸ°ë°","ë‚˜ëŠ”","ë„ˆëŠ”","ìš°ë¦¬ëŠ”","ê·¸","ì´","ì €","ê²ƒ","ìˆ˜","ë•Œ","ì¢€","ë”","ì˜","ê°€","ì´","ì„","ë¥¼","ì€","ëŠ”","ì—","ì™€","ê³¼","ë„","ë¡œ","ì—ì„œ","ì—ê²Œ","í•œ","í•˜ë‹¤"]);
    const parts = t.split(" ").filter(w => w.length >= 2 && !stop.has(w));

    const map = new Map();
    for (const w of parts) map.set(w, (map.get(w) || 0) + 1);
    const top = [...map.entries()].sort((a,b)=>b[1]-a[1]).slice(0,2).map(x=>x[0]);

    const out = (top.length ? top : parts.slice(0,1)).map(normalizeKoreanKeyword);
    return out.filter(Boolean);
  }

// ---- ì²« ë¨¸ë¦¬ë§ ë‹¨ì–´(ì²« ë‹¨ì–´) ë½‘ê¸° ----
function extractHeadword(text){
  const raw = String(text || "").trim();
  if (!raw) return "";

  // ë¬¸ì¥ ë§¨ ì•ì˜ íŠ¹ìˆ˜ë¬¸ì/ì´ëª¨ì§€/ë”°ì˜´í‘œ ê°™ì€ ê±° ì œê±°
  const cleaned = raw
    .replace(/^[^\p{L}\p{N}]+/gu, "")     // ì•ìª½ ê¸°í˜¸ ì œê±°
    .replace(/[^\p{L}\p{N}\s]/gu, " ")    // ì¤‘ê°„ ê¸°í˜¸ëŠ” ê³µë°±í™”
    .replace(/\s+/g, " ")
    .trim();

  if (!cleaned) return "";

  const stop = new Set([
    "ê·¸ë¦¬ê³ ","ê·¸ëŸ¬ë‚˜","ê·¸ë˜ì„œ","í•˜ì§€ë§Œ","ë˜ëŠ”","ê·¸ëŸ°ë°",
    "ë‚˜ëŠ”","ë„ˆëŠ”","ìš°ë¦¬ëŠ”","ê·¸","ì´","ì €","ê²ƒ","ìˆ˜","ë•Œ","ì¢€","ë”"
  ]);

  const parts = cleaned.split(" ").map(s => s.trim()).filter(Boolean);

  // ì²« ë‹¨ì–´ë¶€í„° í›‘ìœ¼ë©´ì„œ: ì¡°ì‚¬ ì œê±° + ë„ˆë¬´ í”í•œ ë§ ê±´ë„ˆë›°ê¸°
  for (const w0 of parts){
    const w = normalizeKoreanKeyword(w0);
    if (w.length < 2) continue;
    if (stop.has(w)) continue;
    return w;
  }

  // ë‹¤ ê±¸ëŸ¬ì¡Œìœ¼ë©´ ê·¸ëƒ¥ ì²« í† í°
  return normalizeKoreanKeyword(parts[0] || "");
}

  function loadAnchor(){
    const raw = localStorage.getItem(ANCHOR_KEY);
    if (!raw) return null;
    const obj = safeJsonParse(raw, null);
    if (!obj || !obj.text) return null;
    return obj;
  }
function isWebUnsafeText(s){
  return /(ì”¨ë°œ|ì‹œë°œ|ë³‘ì‹ |ì¢†|ì¡´ë‚˜|êº¼ì ¸|ì£½ì–´|ì¢ƒë‚˜|ìŒ|ê°œìƒˆë¼|ë¯¸ì¹œë†ˆ|ë¯¸ì¹œë…„)/.test(String(s || ""));
}

 async function renderAnchor(){
  const card = $("anchorCard");
  const txt = $("anchorText");
  const when = $("anchorWhen");
  const from = $("anchorFrom");
  const qEl = $("q");

  const a = (await loadTodayPromoteFromServer()) || loadAnchor();

  if (!card || !txt || !when || !from) return;

  if (!a){
    card.style.display = "none";
    return;
  }

  card.style.display = "block";
  function isWebUnsafeText(s){
  return /(ì”¨ë°œ|ì‹œë°œ|ë³‘ì‹ |ì¢†|ì¡´ë‚˜|êº¼ì ¸|ì£½ì–´|ì¢ƒë‚˜|ìŒ|ê°œìƒˆë¼|ë¯¸ì¹œë†ˆ|ë¯¸ì¹œë…„)/.test(String(s || ""));
}
  txt.textContent = a.text;
  when.textContent = a.createdAt ? `${timeAgo(a.createdAt)} Â· ${a.createdAt}` : "ì‹œê°„ ì—†ìŒ";
  from.textContent = a.source || "meeting-room";

  if (qEl && !String(qEl.value || "").trim()){
    const head = extractHeadword(a.text);
    if (head) qEl.value = head;
  }
  CURRENT_ANCHOR = a;
}

  async function autoInhale(q){
    const keyword = normalizeKoreanKeyword(String(q || "").trim());
    if (!keyword) return toast("í‚¤ì›Œë“œë¥¼ ë¨¼ì € ì ì–´ì¤˜.");

    async function getJson(url){
      const r = await fetch(url);
      if (!r.ok) return null;
      return await r.json();
    }

    const lines = [];

    // ìœ„í‚¤ (ì–¸ì–´ë§Œ)

const src = $("source") ? String($("source").value || "dictionary") : "dictionary";

if (src === "wiki"){
  const wiki = await getJson(`/api/wiki-summary?q=${encodeURIComponent(keyword)}`);
  if (wiki?.summary) lines.push(`${wiki.summary}`);
}

if (src === "paper"){
  const paper = await getJson(`/api/paper-summary?q=${encodeURIComponent(keyword)}`);
  if (paper?.summary) lines.push(`${paper.summary}`);
}

if (src === "dictionary"){
  const dict = await getJson(`/api/dict-summary?q=${encodeURIComponent(keyword)}`);
 if (dict?.summary) {
  lines.push(cleanDictionaryText(dict.summary));
}

}

// etcëŠ” ìš°ì„  ì•„ë¬´ê²ƒë„ ì•ˆ ê°€ì ¸ì˜¤ê±°ë‚˜(ë¹„ì›€), ë‚˜ì¤‘ì— ì¶”ê°€
if (src === "etc"){
  lines.push(`(etc) ì•„ì§ ì—°ê²° ì „ì´ì•¼. wiki / paper / dictionary ì¤‘ í•˜ë‚˜ë¥¼ ë¨¼ì € ê³¨ë¼ì¤˜.`);
}


    const tEl = $("text");
if (tEl){
  // âœ… ê²°ê³¼ ì—†ìœ¼ë©´ textareaëŠ” ë¹„ì›Œë‘”ë‹¤(ì¹¨ë¬µ)
  tEl.value = lines.length ? `${lines.join("\n\n")}` : "";
}

// âœ… bundle ì €ì¥ë„ "ìˆì„ ë•Œë§Œ"
const bundleText = tEl ? tEl.value : "";
if (bundleText.trim()){
  localStorage.setItem(
    CROSS_BUNDLE_KEY,
    JSON.stringify({ keyword, text: bundleText, createdAt: nowIso() })
  );
} else {
  localStorage.removeItem(CROSS_BUNDLE_KEY);
}

   if (lines.length) toast("ë“¤ìˆ¨(ê²€ìƒ‰) ê²°ê³¼ë¥¼ ì±„ì› ì–´.");
else toast("ì‚¬ì „ ê²°ê³¼ê°€ ì—†ì–´ì„œ, ì¡°ìš©íˆ ë¹„ì›Œë‘˜ê²Œ.");
  }

async function goMeaningCross(){
  const anchor = CURRENT_ANCHOR || (await loadTodayPromoteFromServer()) || loadAnchor();
  if (!anchor || !anchor.text){
    toast("ë¨¸ë¬´ëŠ” ìˆ¨ê²°ì´ ì—†ì–´. ë¨¼ì € ìŠ¹ê²© ìˆ¨ì´ ì™€ì•¼ í•´.");
    return;
  }

  const qEl = $("q");
  const tEl = $("text");
  const keyword = qEl ? normalizeKoreanKeyword(String(qEl.value || "").trim()) : "";
  const bundleText = tEl ? String(tEl.value || "").trim() : "";

  // 1) êµì°¨ë°© ë¨¸ë¦¬(ìŠ¹ê²© ì–¸ì–´) = anchorëŠ” í•­ìƒ ë³´ëƒ„
  localStorage.setItem(
    CROSS_INBOX_KEY,
    JSON.stringify([{
      id: "cross-" + Date.now(),
      source: "inhale-inbox(anchor)",
      text: String(anchor.text),
      createdAt: nowIso()
    }])
  );

  // 2) ì™¸ë¶€ì§€ì‹ì€ "ìˆì„ ë•Œë§Œ" ë³´ëƒ„. ì—†ìœ¼ë©´ ì¡°ìš©íˆ ì§€ì›€(ì¹¨ë¬µ)
  if (bundleText){
    localStorage.setItem(
      CROSS_BUNDLE_KEY,
      JSON.stringify({
        keyword: keyword || "(no-keyword)",
        text: bundleText,
        createdAt: nowIso()
      })
    );
  } else {
    localStorage.removeItem(CROSS_BUNDLE_KEY);
  }

// êµì°¨ë¡œ ì´ë™ ì§ì „
if (anchor?.promoteKey) {
  try {
    await fetch("/api/breath/consume", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
  id: anchor.promoteKey,
  to: "meaning-cross",
  reason: bundleText ? "WITH_KNOWLEDGE" : "ANCHOR_ONLY",
  userId: "web",      // ì§€ê¸ˆì€ ì›¹ì´ ëˆŒë €ìœ¼ë‹ˆê¹Œ webìœ¼ë¡œ
  persona: "haru",    // ê¸°ë³¸ ë¬¸ì§€ê¸° = haru
  tags: [
    "inhale-inbox",
    bundleText ? "with-knowledge" : "no-knowledge",
    keyword ? ("keyword:" + keyword) : "keyword:none",
  ],
}),

    });
  } catch {}
}

  // âœ… ì™¸ë¶€ì§€ì‹ ì—†ì–´ë„ êµì°¨ë¡œ ì´ë™
  toast(bundleText ? "ì˜ë¯¸ êµì°¨ë¡œë¡œ ë³´ëƒˆì–´." : "ì™¸ë¶€ì§€ì‹ì€ ë¹„ì–´ ìˆì–´. ì‚¬ì „ì€ ì¹¨ë¬µí–ˆê³ , ìš°ë¦¬ëŠ” íë¦„ì„ ì‡ì.");
  location.href = "/meaning-cross.html?auto=1";
}
  function clearAll(){
    if ($("q")) $("q").value = "";
    if ($("text")) $("text").value = "";
    // bundleë„ ê°™ì´ ë¹„ì›Œì„œ â€œìƒˆ ì¡°í•©â€ ëŠë‚Œ ìœ ì§€
    localStorage.removeItem(CROSS_BUNDLE_KEY);
    toast("ë¹„ì› ì–´. ìƒˆë¡œ ìˆ¨ì„ ë¶ˆëŸ¬ì˜¤ì.");
  }
document.addEventListener("DOMContentLoaded", async () => {
  let lastPromoteKey = "";      // âœ… ë¨¼ì € ì„ ì–¸

  await renderAnchor();
  lastPromoteKey = CURRENT_ANCHOR?.promoteKey || "";  // âœ… ê·¸ ë‹¤ìŒì— ëŒ€ì…

if (isWebUnsafeText(a.text)) {
  card.style.display = "none";
  CURRENT_ANCHOR = null;
  return;
}

txt.textContent = a.text;

  setInterval(async () => {
    const a = await loadTodayPromoteFromServer();
    if (!a || !a.text) return;

    if (a.promoteKey && a.promoteKey !== lastPromoteKey) {
      lastPromoteKey = a.promoteKey;
      await renderAnchor();

      // âœ… 1) ìƒˆ ìˆ¨ì´ ì˜¤ë©´ ì‚¬ì „(ë“¤ìˆ¨) ìë™ ì‹¤í–‰
const qEl2 = $("q");
const tEl2 = $("text");
const qVal2 = String(qEl2?.value || "").trim();
const tVal2 = String(tEl2?.value || "").trim();

if (qVal2 && !tVal2) {
  await autoInhale(qVal2);
}

// âœ… 2) ì›í•˜ë©´ ìë™ìœ¼ë¡œ ì˜ë¯¸ êµì°¨ë¡œê¹Œì§€ ì´ë™
if (AUTO_ON_NEW_PROMOTE) {
  await goMeaningCross();
}

      toast("ìƒˆ ìŠ¹ê²© ìˆ¨ì´ ë„ì°©í–ˆì–´.");
    }
  }, 1200);


  // 2) ì•µì»¤ ë‹¤ì‹œ ê°€ì ¸ì˜¤ê¸° (ì„œë²„ promote ìš°ì„ )
  const anchor = (await loadTodayPromoteFromServer()) || loadAnchor();
  const qEl = $("q");
  const tEl = $("text");

  // 3) í‚¤ì›Œë“œê°€ ë¹„ì–´ìˆìœ¼ë©´ ì•µì»¤ì—ì„œ ë‹¤ì‹œ ë½‘ì•„ì£¼ê¸°
  if (qEl && anchor?.text && !String(qEl.value || "").trim()){
    const head = extractHeadword(anchor.text);
    if (head) qEl.value = head;
  }

  // 4) ìë™ ë“¤ìˆ¨ 1íšŒ (auto=1ì¼ ë•Œë§Œ)
  if (AUTO_MODE && anchor?.text && qEl){
    const qVal = String(qEl.value || "").trim();
    const tVal = tEl ? String(tEl.value || "").trim() : "";
    if (qVal && !tVal){
      await autoInhale(qVal);
    }
  }

  // 5) ìë™ ì˜ë¯¸êµì°¨ ì´ë™ (pushCross=1ì¼ ë•Œë§Œ)
  if (AUTO_MODE && AUTO_PUSH_CROSS){
    // ë“¤ìˆ¨ ê²°ê³¼ê°€ ìˆë“  ì—†ë“  goMeaningCrossëŠ” ì´ë™ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ê³„ë¼ ìˆìŒ
    await goMeaningCross();
    return; // ì´ë™í•˜ë‹ˆê¹Œ ì•„ë˜ ë¦¬ìŠ¤ë„ˆëŠ” ì˜ë¯¸ ì—†ìŒ
  }

  // ===== ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆë“¤ (ê·¸ëŒ€ë¡œ ìœ ì§€) =====
  if (qEl){
    qEl.addEventListener("keydown", async (e) => {
      if (e.key === "Enter"){
        e.preventDefault();
        await autoInhale(qEl.value);
      }
    });

    qEl.addEventListener("blur", async () => {
      const v = String(qEl.value || "").trim();
      if (v) await autoInhale(v);
    });
  }

  $("source")?.addEventListener("change", async () => {
    const v = String(qEl?.value || "").trim();
    if (v) await autoInhale(v);
  });

  $("sendToCross")?.addEventListener("click", goMeaningCross);
  $("clear")?.addEventListener("click", clearAll);
});


})();
</script>
</body>
</html>
