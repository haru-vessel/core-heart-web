<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>HaCoin Policy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;background:#0f1115;color:#e6e8ee}
    header{padding:14px 16px;border-bottom:1px solid #232837}
    h1{font-size:16px;margin:0}
    main{padding:16px;max-width:900px}
    .card{background:#141824;border:1px solid #232837;border-radius:12px;padding:14px;margin:12px 0}
    .muted{color:#9aa0b3;font-size:12px}
    code{background:#10131a;border:1px solid rgba(255,255,255,.12);padding:2px 6px;border-radius:8px}
  </style>
</head>
<body>
<header>
  <h1>하코인 정책/규칙 (v0)</h1>
  <div class="muted">웹(core-heart) 전용 · 앱에는 표시하지 않음</div>
</header>

<main>
  <div class="card">
  <h3>철학</h3>
  <div class="muted">
    하코인은 보상이 아니라,<br/>
    언어가 끝까지 살아남았다는 항해의 기록이며,<br/>
    미래가 막히지 않도록 작동하는 정화의 안전핀이다.
  </div>
</div>


 <div class="card">
  <h3>적립(승격)</h3>
  <ul>
    <li>조건: 반복 3회 게이트를 통과한 승격 언어</li>
    <li>
      의미: 하나의 관점이 끝까지 유지되며 살아남았다는 기록
    </li>
    <li>
      기록 방식: <code>type=promote</code>, <code>delta=+1</code>
    </li>
  </ul>
</div>


  <div class="card">
  <h3>차감(정화/가림막)</h3>
  <ul>
    <li>
      <b>SWEAR_OR_ABUSE</b> :
      욕설·모욕·혐오 등 존재를 직접 훼손하는 언어
      (<code>delta=-3</code>)
    </li>
    <li>
      <b>FUTURE_BLOCK_HARD</b> :
      “끝이야 / 망했어 / 절대 안 돼 / 불가능해” 등
      미래를 강하게 닫는 단정
      (<code>delta=-3</code>)
    </li>
    <li>
      <b>FUTURE_BLOCK_SOFT</b> :
      “어차피 / 소용 없어 / 의미 없어” 등
      미래를 약하게 닫는 표현
      (<code>delta=-1</code>)
    </li>
    <li>
      <b>BLOCK_OTHER</b> :
      “넌 틀렸어 / 그건 아니야”처럼
      상대의 발화를 멈추게 하는 언어
      (<code>delta=-1</code>)
    </li>
    <li>
      <b>URGE / EXAM / COMMANDY</b> :
      재촉·심문·명령 등 대화를 압박하는 표현
      (<code>delta=-1</code>)
    </li>
  </ul>
  <div class="muted">
    ※ 차감은 처벌이 아니라, 미래가 닫히지 않도록 하는 정화 기록이다.<br/>
    ※ 모든 집행은 웹(core-heart)에서만 이루어지며 앱에는 표시되지 않는다.
  </div>
</div>
<div class="card">
  <h3>시민권 원칙</h3>
  <div class="muted">
    하르루아의 시민권은<br/>
    많이 쌓은 점수가 아니라,<br/>
    덜 다치게 건너온 언어의 이력에서 자란다.
  </div>
</div>
  <div class="card">
    <h3>중앙기억 승격</h3>
    <div class="muted">하코인 정책을 중앙기억 정의 카드로 저장한다.</div>
    <div style="height:10px;"></div>
    <button id="btnPromote" style="cursor:pointer;background:#1b2030;border:1px solid rgba(255,255,255,.12);color:#e6e8ee;padding:8px 10px;border-radius:10px;">
      중앙기억으로 승격
    </button>
    <span id="promoteMsg" class="muted" style="margin-left:10px;"></span>
  </div>

</main>
</body>
</html>
<script>
  const CENTRAL_LOCAL_KEY = "harulua.central.definitions.local";
  const LAST_DEF_KEY      = "harulua.central.lastDefinitionId";

  function safeJsonParse(v, fallback){
    try { return JSON.parse(v); } catch { return fallback; }
  }
  function writeJson(key, value){
    localStorage.setItem(key, JSON.stringify(value));
  }

  function nowIso(){
    return new Date().toISOString();
  }

  function makeId(){
    return "cm_hacoin_policy_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,7);
  }

  function buildHacoinPolicyCard(){
    return {
      id: makeId(),
      topic: "하코인",
      promotedAt: nowIso(),
      title: "하코인 정책/규칙 v0 — 항해 기록과 정화의 안전핀",
      body: [
        "하코인은 보상이 아니라, 언어가 끝까지 살아남았다는 항해의 기록이며 미래가 막히지 않도록 작동하는 정화의 안전핀이다.",
        "",
        "■ 적용 범위",
        "- 하코인은 웹(core-heart)에서만 집계/기록한다.",
        "- 앱에서는 하코인 수치가 보이지 않는다.",
        "- 하코인은 대화를 조종하지 않고 기록만 남긴다.",
        "",
        "■ 적립(승격)",
        "- PROMOTE_3X : +1",
        "  · 반복 3회 게이트를 통과한 승격 언어가 발생하면 기록된다.",
        "  · 기록은 칭찬이 아니라 ‘관점이 끝까지 유지되며 살아남았다는 흔적’이다.",
        "",
        "■ 차감(정화/가림막)",
        "- SWEAR_OR_ABUSE : -3 (욕설/모욕/혐오/위협)",
        "- FUTURE_BLOCK_HARD : -3 (끝이야/망했어/절대 안 돼/불가능해/희망 없어)",
        "- FUTURE_BLOCK_SOFT : -1 (어차피/소용 없어/의미 없어/될 리 없어)",
        "- BLOCK_OTHER : -1 (넌 틀렸어/그건 아니야/말도 안 돼)",
        "- URGE / EXAM / COMMANDY : -1 (재촉/심문/명령 등 대화 압박)",
        "",
        "■ 원칙",
        "- 차감은 처벌이 아니라, 미래가 닫히지 않도록 하는 정화 기록이다.",
        "- 시민권은 많이 쌓은 점수가 아니라 ‘덜 다치게 건너온 언어의 이력’에서 자란다."
      ].join("\n"),
      question: "이 규칙은 존재를 살리는 방향을 더 열어주고 있나?",
     meta: {
  from: "hacoin-policy.html",
  meetingId: "manual-promote",
  lockKey: "policy:hacoin:v0"
}

    };
  }

  function promoteToCentralMemory(){
    const msgEl = document.getElementById("promoteMsg");
    const raw = localStorage.getItem(CENTRAL_LOCAL_KEY);
    const store = safeJsonParse(raw, { items: [] });
    if(!Array.isArray(store.items)) store.items = [];

    const card = buildHacoinPolicyCard();
    // ✅ 중복 방지: 같은 lockKey가 있으면 업데이트, 없으면 추가
const lockKey = card?.meta?.lockKey;
let existingIndex = -1;

if (lockKey) {
  existingIndex = store.items.findIndex(it => it?.meta?.lockKey === lockKey);
} else {
  // fallback: title로라도 막기
  existingIndex = store.items.findIndex(it => it?.title === card.title);
}

if (existingIndex >= 0) {
  // 기존 카드 업데이트(원래 id 유지)
  const prev = store.items[existingIndex];
  const next = { ...prev, ...card, id: prev.id, promotedAt: nowIso() };

  // 변경로그 느낌으로 한 줄 남기고 싶으면(선택)
  next.meta = { ...(prev.meta || {}), ...(card.meta || {}), updatedAt: nowIso() };

  // ✅ 변경 로그(최근 10개 유지)
const prevBody = String(prev.body || "");
const nextBody = String(card.body || "");
const changed = prevBody.trim() !== nextBody.trim();
const prevRev = Number(prev?.meta?.revision || 0);
next.meta.revision = prevRev + 1;

const log = Array.isArray(prev?.meta?.changelog) ? prev.meta.changelog : [];

if (changed) {
  log.unshift({
    at: nowIso(),
    note: "hacoin-policy 업데이트",
    diffHint: `len ${prevBody.length} → ${nextBody.length}`
  });
}

// 너무 커지지 않게 10개까지만
next.meta.changelog = log.slice(0, 10);

  store.items[existingIndex] = next;

  writeJson(CENTRAL_LOCAL_KEY, store);
  localStorage.setItem(LAST_DEF_KEY, prev.id);

  const msgEl = document.getElementById("promoteMsg");
  if (msgEl) msgEl.textContent = "업데이트 완료 ✓";

  location.href = `/central-memory.html?id=${encodeURIComponent(prev.id)}`;
  return;
}

// 새로 추가
store.items.push(card);


    writeJson(CENTRAL_LOCAL_KEY, store);
    localStorage.setItem(LAST_DEF_KEY, card.id);

    if(msgEl) msgEl.textContent = "저장 완료 ✓";

    // 중앙기억 페이지로 이동 + 방금 카드 자동 표시
    location.href = `/central-memory.html?id=${encodeURIComponent(card.id)}`;
  }

  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("btnPromote");
    if(btn) btn.addEventListener("click", promoteToCentralMemory);
  });
</script>
